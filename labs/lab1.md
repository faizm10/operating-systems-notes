# **CSI3131 Lab 1 Report: Observing Process Behaviour**

**Name:** Faiz Mustansar
**Student ID:** 
**Date:** May 22nd, 2025

---

## âœ… Step 2: Exploring the `/proc` Filesystem

### ğŸ”§ Command Used:

```bash
ls /proc
```

### ğŸ“¸ Screenshot:

![Listing /proc](image.png)

### ğŸ§  What I Observed:

* The `/proc` directory contained many folders with just numbers like `1`, `10`, `1382`, etc. These represent the **PIDs** (Process IDs) of currently running programs.
* It also had named entries like `cpuinfo`, `version`, `meminfo`, and more. These files contain real-time system information such as CPU details and kernel version.
* The files in `/proc` are **not real files** stored on the hard drive. They are **virtual files** generated by the Linux kernel to show the current state of the system.
---

## âœ… Step 3: Viewing Kernel Version

### ğŸ”§ Command Used:

```bash
cat /proc/version
```

### ğŸ“¸ Screenshot:

![Kernel Version](image-2.png)

### ğŸ§  What I Observed:

```
Linux version 5.10.0-18-arm64 (debian-kernel@lists.debian.org) (gcc-10 (Debian 10.2.1-6) 10.2.1 20210110, GNU ld (GNU Binutils for Debian) 2.35.2) #1 SMP Debian 5.10.140-1 (2022-09-02)
```

* The system is running **Debian Linux** with **kernel version 5.10.0-18**.
* It's using the **ARM 64-bit architecture**.
* The kernel was last built on **September 2, 2022**, using GCC version 10.2.1.

---

## âœ… Step 4: Finding the Shell Process

### ğŸ”§ Command Used:

```bash
ps
```

### ğŸ“¸ Screenshot:

![Shell Process](image-1.png)

### ğŸ§  What I Observed:

* The `ps` command listed two processes:

  * `bash` with PID **1392** (my shell process)
  * `ps` with PID **1409** (the command I just ran)
* This confirms that my terminal session is currently running under **process ID 1392**.

---

Perfect, Faiz â€” youâ€™ve completed both `/proc/1392/stat` and `/proc/1392/status`. Here's how that fits into your lab report, all formatted neatly:

---

## âœ… Step 5: Looking at Shell Process Info

### ğŸ”§ Commands Used:

```bash
cat /proc/1392/stat
cat /proc/1392/status
```

### ğŸ“¸ Screenshots:

* ![alt text](image-3.png)
* ![alt text](image-4.png)
* ![alt text](image-5.png)

### ğŸ§  What I Observed:

#### `/proc/1392/stat`

This file contains one long line of space-separated values that describe the process. Key values include:

* **PID:** 1392
* **Process name:** `(bash)`
* **State:** `S` â†’ Sleeping
* **PPID:** 1387 (Parent process ID)
* **utime/stime:** These are the user and system time values, which show how much CPU time the process has used.

To fully understand the fields, I referred to `man proc`. The stat file is useful for tracking how long the process has run and what state it's in.

---

#### `/proc/1392/status`

This file is more human-readable. Some important values I noted:

* **Name:** bash
* **State:** S (Sleeping)
* **Pid:** 1392
* **PPid:** 1387
* **Threads:** 1
* **VmSize:** 6956 kB (total memory used)
* **VmRSS:** 3512 kB (resident memory)
* **voluntary\_ctxt\_switches:** 246
* **nonvoluntary\_ctxt\_switches:** 3

This shows the process is sleeping (waiting for input), only using a small amount of memory, and has done a few context switches â€” most of them voluntary.

---

## âœ… Step 6: Extracting and Reviewing Files

### ğŸ”§ Command Used:

```bash
tar -xvf lab1.tar
```

### ğŸ“¸ Screenshots:

![alt text](image-6.png)

### ğŸ“ Files Extracted:

* **`calcloop`**: A program that simulates a CPU-bound task. It does calculations in a loop after sleeping for 3 seconds.
* **`cploop`**: A program that simulates an I/O-bound task. It copies a file in a loop after a short delay.
* **`procmon`**: A process monitor that checks `/proc/[PID]/stat` once per second and prints the state, user time, and system time of the target process.
* **`tstcalc`**: A shell script or program that runs `calcloop` and monitors it using `procmon`.
* **`tstcp`**: A script or program that runs `cploop` and monitors it using `procmon`.
* **`mon.c`**: A C file you will later modify or complete. It should automatically launch both the target and monitor programs and handle stopping them.

---

Perfect, Faiz! You successfully ran both `tstcalc` and `tstcp`, and collected their output logs.

Hereâ€™s how Step 7 will look in your lab report:

---

## âœ… Step 7: Running the Programs and Analyzing Logs

### ğŸ”§ Commands Used:

```bash
./tstcalc
cat calc.log
./tstcp
cat cp.log
```

### ğŸ“¸ Screenshots:

* `tstcalc` output:
  ![alt text](image-7.png)
  ![alt text](image-8.png)

* `tstcp` output:
  ![alt text](image-9.png)
  ![alt text](image-10.png)

---

### ğŸ§  What I Observed:

#### `calc.log` â€“ CPU-bound Process (calcloop):

* The process was mostly in **"Running"** state.
* User time (`UsrTm`) increased steadily: 0 â†’ 406.
* System time (`SysTm`) stayed low or at 0.
* This shows the process was using the CPU a lot (doing calculations) but not waiting for I/O.

#### `cp.log` â€“ I/O-bound Process (cploop):

* The process was mostly **"Sleeping (memory)"**.
* Both user time and system time increased very slowly.
* This tells me the process spent a lot of time waiting (probably for I/O like file copying) and didnâ€™t do much processing.

Perfect â€” it looks like your program `mon.c` successfully launched `calcloop`, monitored it using `procmon`, and displayed the results over 20 seconds. Here's how weâ€™ll document **Step 9** in your lab report:

---

## âœ… Step 9-11: Running `mon.c` to Launch and Monitor a Program Automatically

### ğŸ”§ Command Used:

```bash
./mon ./calcloop
```

### ğŸ“¸ Screenshot:

![mon calcloop](image-11.png)

### ğŸ§  What I Observed:

* The `mon` program started `calcloop` and launched `procmon` with the PID of the `calcloop` process.
* `procmon` monitored the `/proc/[pid]/stat` file and printed the process state, system time (`SysTm`), and user time (`UsrTm`) every second.
* The output showed `calcloop` moving between "Running" and "Sleeping(memory)" states. The user time gradually increased, showing that the process was using CPU time.
* After 20 seconds, `procmon` stopped when it could no longer access `/proc/8340/stat`, confirming that `calcloop` was killed by the `mon` program.
